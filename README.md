设计模式
设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。一个设计模式并不是能够用于代码中的，而是提供一个在不同情况下解决问题的模板示例。设计模式允许开发者用一个大家都熟知的编码方式进行交流，有利于软件的扩展性和可维护性。

#设计模式六大原则

1）单一职责原则 （ Single Responsibility Principle ）
单一职责的英文名称是Single Responsibility Principle，缩写是SRP。SRP的定义是：就一个类而言，应该仅有一个引起它变化的原因。简单来说，一个类中应该是一组相关性很高的函数、数据的封装，所以如果类执行的功能过多就要考虑将类进行拆分了。 遵循单一职责原的优点有： 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多； 提高类的可读性，提高系统的可维护性； 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。
2）里氏替换原则 （ Liskov Substitution Principle）
里氏替换原则英文全称是Liskov Substitution Principle， 缩写是LSP。LSP 的第一种定义是：如果对每一个类型为 S 的对象 O1，都有类型为 T 的对象 O2， 使得以 T 定义的所有程序 P 在所有的对象 O1，都代换成 O2 时，程序 P 的行为没有发生变化，那么类型 S 是类型 T 的子类型。上面这种描述确实不太好理解，我们再看看另一个直截了当的定义，里氏替换原则第二种定义：所有引用基类的地方必须能透明的使用其子类的对象。 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。
3）依赖倒置原则 （Dependence Inversion Principle）
依赖倒置原则英文全称是Dependence Inversion Principle ，缩写是DIP。依赖倒置原则指代了一种特定的解耦形势，使得高层次的模块不依赖于低层次的模块实现细节的目的，依赖模块被颠倒了。定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 低层模块尽量都要有抽象类或接口，或者两者都有。 变量的声明类型尽量是抽象类或接口。 使用继承时遵循里氏替换原则。
4）开闭原则 （ Open-Close Principle ）
开闭原则的英文全称是Open Close Principle，缩写是OCP，它是Java世界里最基础的设计原则，它指导我们如何建立一个稳定的、灵活的系统。开闭原则的定义是：软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是，对于修改是封闭的（open for extension and close for modification）。
5）接口隔离原则 （Interface Segregation Principle）
接口隔离原则英文全称是 InterfaceSegregation Principles，缩写是ISP。ISP 的定义是：客户端不应该依赖它不需要的接口。另一种定义是：类间的依赖关系应该建立在最小的接口上。
6）迪米特原则 （ Law of Demeter ）
迪米特原则英文全称为 Law of Demeter， 缩写是LOD，也称为最少知识原则（Least Konwledge Principle）。虽然名字不同，但描述的是同一个原则：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现与调用者或者依赖者没关系，调用者或者依赖者只需要知道它需要的方法即可，其他的可一概不用管。类与类之间的关系越密切，耦合度就越大，当一个类发生改变时，对另一个类的影响也越大。


一、单例模式
单例模式有两种方式：懒汉式跟饿汉式 1、懒汉式，延迟加载的方式，在需要的时候才会去生成实例化对象，通常的做法就是使用双重检查(DoubleCheck)的方式，这种实现方式是线程安全的 2、饿汉式，提前生成实例化对象，因此是线程安全的。可以使用静态内部类的方式进行实现

二、观察者模式
观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象状态发生改变时，它的所有依赖者都会收到通知并自动更新。

三、工厂模式
工厂方法模式（Factory Method Pattern）定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类，这样的设计将对象的创建封装其来，以便于得到更松耦合，更有弹性的设计。

四、抽象工厂模式
工厂方法模式中工厂类生产出来的产品都是具体的，也就是说每个工厂都会生产某一种具体的产品，但是如果工厂类中所生产出来的产品是多种多样的，工厂方法模式也就不再适用了，就要使用抽象工厂模式了。

五、适配器模式
适配器模式把一个类的接口换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

六、装饰者模式
装饰者模式（Decorator Pattern），装饰者模式也称为包装模式（Wrapper Pattern），结构型模式之一，其使用一种对客户端透明的方式来动态的扩展对象的功能，同时它也是继承关系的一种替代方案之一，但比继承更加灵活。在现实生活中也可以看到很多装饰者模式的例子，或者可以大胆的说装饰者模式无处不在，就拿一件东西来说，可以给它披上无数层不一样的外壳，但是这件东西还是这件东西，外壳不过是用来扩展这个东西的功能而已，这就是装饰者模式，装饰者的这个角色也许各不相同但是被装饰的对象本质是不变的。

七、桥接模式
桥接模式，作用是将一个系统的抽象部分和实现部分分离，使它们都可以独立地进行变化，对应到上面就是赛车的种类可以相对变化，轮胎的种类可以相对变化，形成一种交叉的关系，最后的结果就是一种赛车对应一种轮胎就能够成功产生一种结果和行为。

八、代理模式
代理模式也称为委托模式，是一个非常重要的设计模式，不少设计模式也都会有代理模式的影子。代理在我们日常生活中也很常见，比如上网时连接的代理服务器地址，更比如我们平时租房子，将找房子的过程代理给中介等等，都是代理模式在日常生活中的使用例子。 九、建造者模式
建造者模式（Builder Pattern），建造者模式又被称为生成器模式，是创造性模式之一，与工厂方法模式和抽象工厂模式不同，后两者的目的是为了实现多态性，而 Builder 模式的目的则是为了将对象的构建与展示分离